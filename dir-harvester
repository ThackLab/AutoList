#!/bin/bash

#==============================================================================
# CONFIGURATION
#==============================================================================
WORDLIST=~/wordlists/Dir-Harvester.txt
STATE_FILE=~/.dir-harvester-state
LOG_FILE=~/.dir-harvester.log

# Directories to monitor (recursively searches subdirectories)
WATCH_DIRS=(
    ~/ctf
    ~/Desktop
    ~/Downloads
    ~/Documents
)

# Patterns to exclude (garbage directories)
EXCLUDE_PATTERNS=(
    "css"
    "js"
    "javascript"
    "images"
    "img"
    "static"
    "fonts"
    "icons"
    "vendor"
    "node_modules"
    "bower_components"
    ".git"
    ".svn"
    "dist"
    "build"
    "cache"
)

#==============================================================================
# INITIALIZE
#==============================================================================
touch $WORDLIST
touch $STATE_FILE
touch $LOG_FILE

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

#==============================================================================
# EXTRACT DIRECTORIES FROM SCAN OUTPUT
#==============================================================================
extract_dirs() {
    local file=$1
    local temp_file=$(mktemp)
    
    # Detect tool and extract paths
    if grep -q "Gobuster\|Status:" "$file" 2>/dev/null; then
        # Gobuster: /admin (Status: 200) [Size: 1234]
        grep -E "\(Status: (200|301|302|307|308)" "$file" | awk '{print $1}' | sed 's|^/||; s|/$||' >> $temp_file
        
    elif grep -q "DIRB" "$file" 2>/dev/null; then
        # Dirb directories: ==> DIRECTORY: http://target/admin/
        grep "==> DIRECTORY:" "$file" | awk '{print $NF}' | sed 's|.*/||; s|/$||' >> $temp_file
        # Dirb files: + http://target/admin (CODE:200)
        grep -E "CODE:(200|301|302|307|308)" "$file" | awk '{print $2}' | sed 's|.*/||; s|/$||' >> $temp_file
        
    elif grep -q "feroxbuster" "$file" 2>/dev/null; then
        # Feroxbuster: 200 GET 10l 20w 123c http://target/admin
        grep -E "^(200|301|302|307|308)\s+GET" "$file" | awk '{print $NF}' | sed 's|.*/||; s|/$||' >> $temp_file
        
    elif grep -q "dirsearch" "$file" 2>/dev/null; then
        # Dirsearch: [12:34:56] 200 - /admin
        grep -E "^\[.*\] (200|301|302|307|308)" "$file" | awk '{print $NF}' | sed 's|^/||; s|/$||' >> $temp_file
    
    elif grep -E "\[Status:|v[0-9]+\.[0-9]" "$file" 2>/dev/null | grep -q "Status:"; then
        # ffuf: admin [Status: 200, Size: 4934, Words: 637, Lines: 120]
        grep -E "\[Status: (200|301|302|307|308)" "$file" | awk '{print $1}' | sed 's|^/||; s|/$||' >> $temp_file
    fi
    
    # Filter out excluded patterns
    while IFS= read -r dir; do
        # Skip empty lines
        [ -z "$dir" ] && continue
        
        # Check if matches any exclude pattern
        local excluded=false
        for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            if [[ "$dir" == *"$pattern"* ]]; then
                excluded=true
                break
            fi
        done
        
        # Skip files with extensions (only want directories)
        if [[ "$dir" =~ \.[a-zA-Z0-9]{2,5}$ ]]; then
            excluded=true
        fi
        
        # Add if not excluded
        if [ "$excluded" = false ]; then
            echo "$dir"
        fi
    done < $temp_file
    
    rm $temp_file
}

#==============================================================================
# CHECK IF FILE HAS BEEN PROCESSED
#==============================================================================
is_processed() {
    local file=$1
    local file_hash=$(md5sum "$file" | awk '{print $1}')
    
    grep -q "$file_hash" $STATE_FILE
    return $?
}

mark_processed() {
    local file=$1
    local file_hash=$(md5sum "$file" | awk '{print $1}')
    
    echo "$file_hash $file $(date +%s)" >> $STATE_FILE
}

#==============================================================================
# PROCESS A SINGLE FILE
#==============================================================================
process_file() {
    local file=$1
    
    # Check if filename matches our patterns
    if ! echo "$file" | grep -qE "(gobuster|dirb|feroxbuster|ferox|dirsearch|ffuf).*\.txt$"; then
        return
    fi
    
    # Skip if already processed
    if is_processed "$file"; then
        return
    fi
    
    log "Processing new file: $file"
    
    # Extract directories
    BEFORE=$(wc -l < $WORDLIST)
    extract_dirs "$file" >> $WORDLIST
    
    # Deduplicate
    sort -u $WORDLIST -o $WORDLIST
    
    AFTER=$(wc -l < $WORDLIST)
    ADDED=$((AFTER - BEFORE))
    
    if [ $ADDED -gt 0 ]; then
        log "Added $ADDED new directories (total: $AFTER)"
    fi
    
    # Mark as processed
    mark_processed "$file"
}

#==============================================================================
# SCAN EXISTING FILES ON STARTUP
#==============================================================================
scan_existing_files() {
    log "Scanning for existing files..."
    local count=0
    
    # Build find command for all watch directories
    local find_paths=()
    for dir in "${WATCH_DIRS[@]}"; do
        local expanded_dir="${dir/#\~/$HOME}"
        if [ -d "$expanded_dir" ]; then
            find_paths+=("$expanded_dir")
        fi
    done
    
    if [ ${#find_paths[@]} -eq 0 ]; then
        log "No valid watch directories found"
        return
    fi
    
    # Process existing files
    while IFS= read -r file; do
        process_file "$file"
        ((count++))
    done < <(find "${find_paths[@]}" -type f \( -name "*gobuster*.txt" -o -name "*dirb*.txt" -o -name "*feroxbuster*.txt" -o -name "*ferox*.txt" -o -name "*dirsearch*.txt" -o -name "*ffuf*.txt" \) -mtime -7 2>/dev/null)
    
    log "Initial scan complete: checked $count files"
}

#==============================================================================
# DAEMON STATUS CHECK
#==============================================================================
check_daemon_status() {
    if pgrep -f "dir-harvester daemon" > /dev/null; then
        echo "✓ Daemon is running (PID: $(pgrep -f 'dir-harvester daemon'))"
        return 0
    else
        echo "✗ Daemon is not running"
        return 1
    fi
}

#==============================================================================
# MAIN DAEMON LOOP - LIVE FILE WATCHING
#==============================================================================
if [ "$1" = "daemon" ]; then
    # Check if inotify-tools is installed
    if ! command -v inotifywait &> /dev/null; then
        log "ERROR: inotify-tools not installed"
        echo "Install with: sudo apt install inotify-tools"
        exit 1
    fi
    
    log "Starting dir-harvester daemon (LIVE MODE)"
    log "PID: $$"
    log "Monitoring directories: ${WATCH_DIRS[*]}"
    
    # Scan existing files first
    scan_existing_files
    
    # Build watch paths
    local watch_paths=()
    for dir in "${WATCH_DIRS[@]}"; do
        local expanded_dir="${dir/#\~/$HOME}"
        if [ -d "$expanded_dir" ]; then
            watch_paths+=("$expanded_dir")
        fi
    done
    
    if [ ${#watch_paths[@]} -eq 0 ]; then
        log "ERROR: No valid watch directories found"
        exit 1
    fi
    
    log "Starting LIVE file monitoring..."
    
    # Watch for file creation and modification events
    inotifywait -m -r -e close_write,moved_to --format '%w%f' "${watch_paths[@]}" 2>/dev/null | while read file; do
        # Process the file if it matches our patterns
        if echo "$file" | grep -qE "(gobuster|dirb|feroxbuster|ferox|dirsearch|ffuf).*\.txt$"; then
            # Small delay to ensure file is fully written
            sleep 0.5
            process_file "$file"
        fi
    done
    
#==============================================================================
# MANUAL SINGLE SCAN
#==============================================================================
elif [ "$1" = "scan" ]; then
    log "Running manual scan"
    scan_existing_files
    log "Scan complete. Wordlist: $WORDLIST ($(wc -l < $WORDLIST) entries)"
    
#==============================================================================
# ADD CUSTOM EXCLUDE PATTERN
#==============================================================================
elif [ "$1" = "exclude" ]; then
    if [ -z "$2" ]; then
        echo "Usage: $0 exclude <pattern>"
        exit 1
    fi
    
    log "Add this to EXCLUDE_PATTERNS array: \"$2\""
    echo "Edit ~/My-Projects/dir-harvester and add \"$2\" to EXCLUDE_PATTERNS"
    
#==============================================================================
# SHOW STATS
#==============================================================================
elif [ "$1" = "stats" ]; then
    echo "=== Dir Harvester Stats ==="
    echo "Wordlist: $WORDLIST"
    echo "Total directories: $(wc -l < $WORDLIST 2>/dev/null || echo 0)"
    echo "Files processed: $(wc -l < $STATE_FILE 2>/dev/null || echo 0)"
    echo ""
    check_daemon_status
    echo ""
    echo "Last 10 log entries:"
    tail -10 $LOG_FILE 2>/dev/null || echo "No log entries"

#==============================================================================
# START DAEMON IN BACKGROUND
#==============================================================================
elif [ "$1" = "start" ]; then
    if pgrep -f "dir-harvester daemon" > /dev/null; then
        echo "Daemon is already running (PID: $(pgrep -f 'dir-harvester daemon'))"
        exit 1
    fi
    
    nohup "$0" daemon > /dev/null 2>&1 &
    sleep 1
    
    if pgrep -f "dir-harvester daemon" > /dev/null; then
        echo "✓ Daemon started successfully (PID: $(pgrep -f 'dir-harvester daemon'))"
        log "Daemon started via 'start' command"
    else
        echo "✗ Failed to start daemon"
        exit 1
    fi

#==============================================================================
# STOP DAEMON
#==============================================================================
elif [ "$1" = "stop" ]; then
    if ! pgrep -f "dir-harvester daemon" > /dev/null; then
        echo "Daemon is not running"
        exit 1
    fi
    
    pkill -f "dir-harvester daemon"
    sleep 1
    
    if ! pgrep -f "dir-harvester daemon" > /dev/null; then
        echo "✓ Daemon stopped"
        log "Daemon stopped via 'stop' command"
    else
        echo "✗ Failed to stop daemon"
        exit 1
    fi

#==============================================================================
# SHOW STATUS
#==============================================================================
elif [ "$1" = "status" ]; then
    check_daemon_status
    
else
    echo "Dir Harvester - Automated Directory Wordlist Builder"
    echo ""
    echo "Usage:"
    echo "  $0 start     # Start daemon in background (LIVE monitoring)"
    echo "  $0 stop      # Stop daemon"
    echo "  $0 status    # Check daemon status"
    echo "  $0 daemon    # Run as daemon (foreground)"
    echo "  $0 scan      # Manual scan once"
    echo "  $0 exclude <pattern>  # Add pattern to exclusion list"
    echo "  $0 stats     # Show statistics"
    echo ""
    echo "Configuration:"
    echo "  Wordlist: $WORDLIST"
    echo "  Watch dirs: ${WATCH_DIRS[*]}"
    echo "  Log file: $LOG_FILE"
    echo ""
    echo "Supported tools: gobuster, dirb, feroxbuster, ffuf, dirsearch"
    echo "Requires: inotify-tools (install: sudo apt install inotify-tools)"
fi 
